---
const {
  particleCount = 200,
  particleSpread = 10,
  speed = 0.1,
  particleColors,
  moveParticlesOnHover = false,
  particleHoverFactor = 1,
  alphaParticles = false,
  particleBaseSize = 100,
  sizeRandomness = 1,
  cameraDistance = 20,
  disableRotation = false,
  className,
} = Astro.props;
---

<astro-particles>
  <div
    class={"particles-container w-full h-full " + className}
    data-particleCount={particleCount}
    data-particleSpread={particleSpread}
    data-speed={speed}
    data-particleColors={particleColors}
    data-moveParticlesOnHover={moveParticlesOnHover}
    data-particleHoverFactor={particleHoverFactor}
    data-alphaParticles={alphaParticles}
    data-particleBaseSize={particleBaseSize}
    data-sizeRandomness={sizeRandomness}
    data-cameraDistance={cameraDistance}
    data-disableRotation={disableRotation}
  >
  </div>
</astro-particles>

<script>
  // https://docs.astro.build/en/guides/client-side-scripts/#web-components-with-custom-elements
  import { Renderer, Program, Mesh, Camera, Geometry } from "ogl";
  import { VERT, FRAG } from "./particles.glsl";

  const defaultColors = [
    "#fbf8cc",
    "#fde4cf",
    "#ffcfd2",
    "#f1c0e8",
    "#cfbaf0",
    "#a3c4f3",
    "#90dbf4",
    "#8eecf5",
    "#98f5e1",
    "#b9fbc0",
  ];

  const hexToRgb = (hex) => {
    hex = hex.replace(/^#/, "");
    if (hex.length === 3) {
      hex = hex
        .split("")
        .map((c) => c + c)
        .join("");
    }
    const int = parseInt(hex, 16);
    const r = ((int >> 16) & 255) / 255;
    const g = ((int >> 8) & 255) / 255;
    const b = (int & 255) / 255;
    return [r, g, b];
  };

  class AstroParticles extends HTMLElement {
    mouseRef = { current: { x: 0, y: 0 } };

    ctn: HTMLElement;
    particleCount: number;
    particleSpread: number;
    speed: number;
    particleColors: string[];
    moveParticlesOnHover: boolean;
    particleHoverFactor: number;
    alphaParticles: boolean;
    particleBaseSize: number;
    sizeRandomness: number;
    cameraDistance: number;
    disableRotation: boolean;
    renderer: Renderer;
    camera: Camera;
    animationFrameId: number;

    resize = () => {
      const width = this.ctn.clientWidth;
      const height = this.ctn.clientHeight;
      this.renderer.setSize(width, height);
      const gl = this.renderer.gl;
      this.camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });
    };

    handleMouseMove = (e) => {
      // console.log("handleMouseMove", e);
      const rect = this.ctn.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      this.mouseRef.current = { x, y };
    };

    handleTouchMove = (e) => {
      // console.log("handleMouseMove", e);
      const rect = this.ctn.getBoundingClientRect();
      const x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
      const y = -(((e.touches[0].clientY - rect.top) / rect.height) * 2 - 1);
      this.mouseRef.current = { x, y };
    };

    connectedCallback() {
      //const ctn = document.getElementById("particles-container"); //ctnDom.current;
      this.ctn = this.querySelector(".particles-container") as HTMLElement;

      const {
        particlecount,
        particlespread,
        speed,
        particlecolors,
        moveparticlesonhover,
        particlehoverfactor,
        alphaparticles,
        particlebasesize,
        sizerandomness,
        cameradistance,
        disablerotation,
      } = this.ctn.dataset;

      this.particleCount = parseInt(particlecount);
      this.particleSpread = parseFloat(particlespread);
      this.speed = parseFloat(speed);
      this.particleColors = particlecolors ? particlecolors.split(",") : null;
      this.moveParticlesOnHover = moveparticlesonhover === "true";
      this.particleHoverFactor = parseFloat(particlehoverfactor);
      this.alphaParticles = alphaparticles === "true";
      this.particleBaseSize = parseFloat(particlebasesize);
      this.sizeRandomness = parseFloat(sizerandomness);
      this.cameraDistance = parseFloat(cameradistance);
      this.disableRotation = disablerotation === "true";

      if (!this.ctn) return;

      this.renderer = new Renderer({ depth: false, alpha: true });

      const gl = this.renderer.gl;
      this.ctn.appendChild(gl.canvas);
      gl.clearColor(0, 0, 0, 0);

      this.camera = new Camera(gl, { fov: 15 });
      this.camera.position.set(0, 0, this.cameraDistance);

      window.addEventListener("resize", this.resize, false);
      this.resize();

      if (this.moveParticlesOnHover) {
        this.ctn.addEventListener("mousemove", this.handleMouseMove);
        // also on mobile:
        this.ctn.addEventListener("touchmove", this.handleTouchMove);
      }

      const count = this.particleCount;
      const positions = new Float32Array(count * 3);
      const randoms = new Float32Array(count * 4);
      const colors = new Float32Array(count * 3);
      const palette =
        this.particleColors && this.particleColors.length > 0
          ? this.particleColors
          : defaultColors;

      for (let i = 0; i < count; i++) {
        let x, y, z, len;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          z = Math.random() * 2 - 1;
          len = x * x + y * y + z * z;
        } while (len > 1 || len === 0);
        const r = Math.cbrt(Math.random());
        positions.set([x * r, y * r, z * r], i * 3);
        randoms.set(
          [Math.random(), Math.random(), Math.random(), Math.random()],
          i * 4
        );
        const col = hexToRgb(
          palette[Math.floor(Math.random() * palette.length)]
        );
        colors.set(col, i * 3);
      }

      const geometry = new Geometry(gl, {
        position: { size: 3, data: positions },
        random: { size: 4, data: randoms },
        color: { size: 3, data: colors },
      });

      const program = new Program(gl, {
        vertex: VERT,
        fragment: FRAG,
        uniforms: {
          uTime: { value: 0 },
          uSpread: { value: this.particleSpread },
          uBaseSize: { value: this.particleBaseSize },
          uSizeRandomness: { value: this.sizeRandomness },
          uAlphaParticles: { value: this.alphaParticles ? 1 : 0 },
        },
        transparent: true,
        depthTest: false,
      });

      const particles = new Mesh(gl, { mode: gl.POINTS, geometry, program });

      let animationFrameId;
      let lastTime = performance.now();
      let elapsed = 0;

      const update = (t) => {
        animationFrameId = requestAnimationFrame(update);
        const delta = t - lastTime;
        lastTime = t;
        elapsed += delta * this.speed;

        program.uniforms.uTime.value = elapsed * 0.001;

        if (this.moveParticlesOnHover) {
          particles.position.x =
            -this.mouseRef.current.x * this.particleHoverFactor;
          particles.position.y =
            -this.mouseRef.current.y * this.particleHoverFactor;
        } else {
          particles.position.x = 0;
          particles.position.y = 0;
        }

        if (!this.disableRotation) {
          particles.rotation.x = Math.sin(elapsed * 0.0002) * 0.1;
          particles.rotation.y = Math.cos(elapsed * 0.0005) * 0.15;
          particles.rotation.z += 0.01 * this.speed;
        }

        this.renderer.render({ scene: particles, camera: this.camera });
      };

      animationFrameId = requestAnimationFrame(update);
    }

    disconnectedCallback() {
      // console.log("disconnectedCallback");
      window.removeEventListener("resize", this.resize);
      if (this.moveParticlesOnHover) {
        this.ctn.removeEventListener("mousemove", this.handleMouseMove);
        this.ctn.removeEventListener("touchmove", this.handleTouchMove);
      }
      cancelAnimationFrame(this.animationFrameId);
      if (this.ctn.contains(this.renderer.gl.canvas)) {
        this.ctn.removeChild(this.renderer.gl.canvas);
      }
    }
  }

  // Tell the browser to use our AstroParticles class for <astro-particles> elements.
  customElements.define("astro-particles", AstroParticles);
</script>
